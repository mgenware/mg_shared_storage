{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Check out pub.dev/shared_storage Stability \u00b6 The latest version is a Beta release, which means all these APIs can change over a short period of time without prior notice. So, please be aware that this is plugin is not intended for production usage yet, since the API is currently in development. Installation \u00b6 Use latest version when installing this plugin: flutter pub add shared_storage or dependencies : shared_storage : ^latest # Pickup the latest version either from the pub.dev page or doc badge Plugin \u00b6 This plugin include partial support for the following APIs: Partial Support for Environment \u00b6 Mirror API from Environment import 'package:shared_storage/environment.dart' as environment ; Partial Support for Media Store \u00b6 Mirror API from MediaStore provider import 'package:shared_storage/media_store.dart' as mediastore ; Partial Support for Storage Access Framework \u00b6 Mirror API from Storage Access Framework import 'package:shared_storage/saf.dart' as saf ; All these APIs are module based, which means they are implemented separadely and so you need to import those you want use. To request support for some API that is not currently included open a issue explaining your usecase and the API you want to make available, the same applies for new methods or activities for the current APIs. Support \u00b6 If you have ideas to share, bugs to report or need support, you can either open an issue or join our Discord server . Android APIs \u00b6 Most Flutter plugins use Android API's under the hood. So this plugin does the same, and to call native Android storage APIs the following API's are being used: \ud83d\udd17android.os.Environment \ud83d\udd17android.provider.MediaStore \ud83d\udd17android.provider.DocumentsProvider Contributors \u00b6 These are the brilliant minds behind the development of this plugin! Alex Rintt \ud83d\udcbb \ud83d\udea7 \ud83d\udcd6 ankitparmar007 \ud83d\udc1b www.bibliotecaortodoxa.ro \ud83d\udcbb \ud83d\udc1b \ud83e\udd14 dangilbert \ud83d\udcbb \ud83d\udc1b dhaval-k-simformsolutions \ud83d\udc1b \ud83e\udd14 Daniel Dunn \ud83d\udc1b \ud83d\udcbb \ud83d\udcd6 jfaltis \ud83d\udc1b \ud83d\udcbb \ud83d\udcd6","title":"Home"},{"location":"#stability","text":"The latest version is a Beta release, which means all these APIs can change over a short period of time without prior notice. So, please be aware that this is plugin is not intended for production usage yet, since the API is currently in development.","title":"Stability"},{"location":"#installation","text":"Use latest version when installing this plugin: flutter pub add shared_storage or dependencies : shared_storage : ^latest # Pickup the latest version either from the pub.dev page or doc badge","title":"Installation"},{"location":"#plugin","text":"This plugin include partial support for the following APIs:","title":"Plugin"},{"location":"#partial-support-for-environment","text":"Mirror API from Environment import 'package:shared_storage/environment.dart' as environment ;","title":"Partial Support for Environment"},{"location":"#partial-support-for-media-store","text":"Mirror API from MediaStore provider import 'package:shared_storage/media_store.dart' as mediastore ;","title":"Partial Support for Media Store"},{"location":"#partial-support-for-storage-access-framework","text":"Mirror API from Storage Access Framework import 'package:shared_storage/saf.dart' as saf ; All these APIs are module based, which means they are implemented separadely and so you need to import those you want use. To request support for some API that is not currently included open a issue explaining your usecase and the API you want to make available, the same applies for new methods or activities for the current APIs.","title":"Partial Support for Storage Access Framework"},{"location":"#support","text":"If you have ideas to share, bugs to report or need support, you can either open an issue or join our Discord server .","title":"Support"},{"location":"#android-apis","text":"Most Flutter plugins use Android API's under the hood. So this plugin does the same, and to call native Android storage APIs the following API's are being used: \ud83d\udd17android.os.Environment \ud83d\udd17android.provider.MediaStore \ud83d\udd17android.provider.DocumentsProvider","title":"Android APIs"},{"location":"#contributors","text":"These are the brilliant minds behind the development of this plugin! Alex Rintt \ud83d\udcbb \ud83d\udea7 \ud83d\udcd6 ankitparmar007 \ud83d\udc1b www.bibliotecaortodoxa.ro \ud83d\udcbb \ud83d\udc1b \ud83e\udd14 dangilbert \ud83d\udcbb \ud83d\udc1b dhaval-k-simformsolutions \ud83d\udc1b \ud83e\udd14 Daniel Dunn \ud83d\udc1b \ud83d\udcbb \ud83d\udcd6 jfaltis \ud83d\udc1b \ud83d\udcbb \ud83d\udcd6","title":"Contributors"},{"location":"Contributing/Ways%20to%20contribute/","text":"How can I contribute? \u00b6 Code is not the only thing matters when we talk about packages and open-source libraries, there's a lot of another tasks which are equally important: Reporting bugs. Creating show-cases. Improving documentation. Asking questions. Answering questions. Sharing ideas. Reporting usage issues (Something looks wrong on API?).","title":"Ways to contribute"},{"location":"Contributing/Ways%20to%20contribute/#how-can-i-contribute","text":"Code is not the only thing matters when we talk about packages and open-source libraries, there's a lot of another tasks which are equally important: Reporting bugs. Creating show-cases. Improving documentation. Asking questions. Answering questions. Sharing ideas. Reporting usage issues (Something looks wrong on API?).","title":"How can I contribute?"},{"location":"Contributing/Setup%20environment/Debugging%20plugin/","text":"First you need follow the guide Setup local environment in order to read this guide Since this is an Android plugin, you'll need to use Android Studio in order to have a full intellisense and debugging features for Kotlin. You can also use Visual Studio Code for Dart and Android Studio for Kotlin. Android Side \u00b6 All android plugin is inside /android folder. There a few steps in order to start debugging this plugin: Open the project inside Android Studio. Right click on /android folder. Flutter > Open Android module in Android Studio > New Window . Done, all completing features will be available. See Flutter docs for details . Dart Side \u00b6 There's no additional step. Just open the directory inside your preferable editor. Happy hacking.","title":"Debugging plugin"},{"location":"Contributing/Setup%20environment/Debugging%20plugin/#android-side","text":"All android plugin is inside /android folder. There a few steps in order to start debugging this plugin: Open the project inside Android Studio. Right click on /android folder. Flutter > Open Android module in Android Studio > New Window . Done, all completing features will be available. See Flutter docs for details .","title":"Android Side"},{"location":"Contributing/Setup%20environment/Debugging%20plugin/#dart-side","text":"There's no additional step. Just open the directory inside your preferable editor. Happy hacking.","title":"Dart Side"},{"location":"Contributing/Setup%20environment/Setup%20local%20environment/","text":"If you already have Flutter configured you can skip this step Setting up your local environment \u00b6 All you need is to make sure you can run Flutter apps in your machine from your shell, by flutter run inside your Flutter project as well you can also run your Flutter project inside Android Studio IDE. Since this IDE support Android process debugging. Configuring Flutter \u00b6 You should configure your Flutter local environment properly. There's several online resources can help you do that as well the official documentation: Flutter Official documentation How to Install and Set Up Flutter on Ubuntu 16.04+ Flutter \u2013 Installation on macOS How to Install Flutter on Windows? In summary: all you need to do is to setup Android plus the Flutter binaries available globally through your CLI interface. To ensure everything is working, type flutter doctor in your shell, you should see something like this: Doctor summary (to see all details, run flutter doctor -v): [\u221a] Flutter (Channel stable, 2.10.0, on Microsoft Windows [Version 10.0.19043.1645], locale en-US) [\u221a] Android toolchain - develop for Android devices (Android SDK version 31.0.0) [\u221a] Chrome - develop for the web [\u221a] Visual Studio - develop for Windows (Visual Studio Build Tools 2019 16.11.13) [\u221a] Android Studio (version 2020.3) [\u221a] IntelliJ IDEA Community Edition (version 2021.3) [\u221a] Connected device (2 available) ! Device RX8M40FQ3KF is offline. [\u221a] HTTP Host Availability \u2022 No issues found!","title":"Setup local environment"},{"location":"Contributing/Setup%20environment/Setup%20local%20environment/#setting-up-your-local-environment","text":"All you need is to make sure you can run Flutter apps in your machine from your shell, by flutter run inside your Flutter project as well you can also run your Flutter project inside Android Studio IDE. Since this IDE support Android process debugging.","title":"Setting up your local environment"},{"location":"Contributing/Setup%20environment/Setup%20local%20environment/#configuring-flutter","text":"You should configure your Flutter local environment properly. There's several online resources can help you do that as well the official documentation: Flutter Official documentation How to Install and Set Up Flutter on Ubuntu 16.04+ Flutter \u2013 Installation on macOS How to Install Flutter on Windows? In summary: all you need to do is to setup Android plus the Flutter binaries available globally through your CLI interface. To ensure everything is working, type flutter doctor in your shell, you should see something like this: Doctor summary (to see all details, run flutter doctor -v): [\u221a] Flutter (Channel stable, 2.10.0, on Microsoft Windows [Version 10.0.19043.1645], locale en-US) [\u221a] Android toolchain - develop for Android devices (Android SDK version 31.0.0) [\u221a] Chrome - develop for the web [\u221a] Visual Studio - develop for Windows (Visual Studio Build Tools 2019 16.11.13) [\u221a] Android Studio (version 2020.3) [\u221a] IntelliJ IDEA Community Edition (version 2021.3) [\u221a] Connected device (2 available) ! Device RX8M40FQ3KF is offline. [\u221a] HTTP Host Availability \u2022 No issues found!","title":"Configuring Flutter"},{"location":"Migrate%20notes/Migrate%20to%20v0.3.0/","text":"There's some breaking changes from v0.2.x then be careful when updating on pubspec.yaml pubspec.yaml dependecy manager file: dependencies : shared_storage : v0.3.0 SDK constraint \u00b6 In android\\app\\build.gradle set android.defaultConfig.minSdkVersion to 19 : android { ... defaultConfig { ... minSdkVersion 19 } ... } Plugin import \u00b6 Although this import is still supported: import 'package:shared_storage/shared_storage.dart' as shared_storage ; This should be renamed to any of them or all: import 'package:shared_storage/saf.dart' as saf ; import 'package:shared_storage/media_store.dart' as media_store ; import 'package:shared_storage/environment.dart' as environment ; Choose which modules/imports one you want to include inside in your project. Media Store getMediaStoreContentDirectory \u00b6 The method getMediaStoreContentDirectory now returns the right class Uri instead of a Directory . Be sure to update all ocurrences. This Uri is used to represent a directory.","title":"Migrate to v0.3.0"},{"location":"Migrate%20notes/Migrate%20to%20v0.3.0/#sdk-constraint","text":"In android\\app\\build.gradle set android.defaultConfig.minSdkVersion to 19 : android { ... defaultConfig { ... minSdkVersion 19 } ... }","title":"SDK constraint"},{"location":"Migrate%20notes/Migrate%20to%20v0.3.0/#plugin-import","text":"Although this import is still supported: import 'package:shared_storage/shared_storage.dart' as shared_storage ; This should be renamed to any of them or all: import 'package:shared_storage/saf.dart' as saf ; import 'package:shared_storage/media_store.dart' as media_store ; import 'package:shared_storage/environment.dart' as environment ; Choose which modules/imports one you want to include inside in your project.","title":"Plugin import"},{"location":"Migrate%20notes/Migrate%20to%20v0.3.0/#media-store-getmediastorecontentdirectory","text":"The method getMediaStoreContentDirectory now returns the right class Uri instead of a Directory . Be sure to update all ocurrences. This Uri is used to represent a directory.","title":"Media Store getMediaStoreContentDirectory"},{"location":"Migrate%20notes/Migrate%20to%20v0.5.0/","text":"There's major breaking changes when updating to v0.5.0 , be careful. Update your pubspec.yaml : dependencies : shared_storage : ^0.5.0 Return type of listFiles \u00b6 Instead of: Stream < PartialDocumentFile > fileStream = listFiles ( uri ); use: Stream < DocumentFile > fileStream = listFiles ( uri ); And when reading data from each file: // Old. PartialDocumentFile file = ... String displayName = file . data ! [ DocumentFileColumn . displayName ] as String ; DateTime lastModified = DateTime . fromMillisecondsSinceEpoch ( file . data ! [ DocumentFileColumn . lastModified ] as int ); // New. DocumentFile file = ... String displayName = file . name ; DateTime lastModified = file . lastModified ; It now parses all fields as class fields instead Map<DocumentFileColumn, dynamic> hash map.","title":"Migrate to v0.5.0"},{"location":"Migrate%20notes/Migrate%20to%20v0.5.0/#return-type-of-listfiles","text":"Instead of: Stream < PartialDocumentFile > fileStream = listFiles ( uri ); use: Stream < DocumentFile > fileStream = listFiles ( uri ); And when reading data from each file: // Old. PartialDocumentFile file = ... String displayName = file . data ! [ DocumentFileColumn . displayName ] as String ; DateTime lastModified = DateTime . fromMillisecondsSinceEpoch ( file . data ! [ DocumentFileColumn . lastModified ] as int ); // New. DocumentFile file = ... String displayName = file . name ; DateTime lastModified = file . lastModified ; It now parses all fields as class fields instead Map<DocumentFileColumn, dynamic> hash map.","title":"Return type of listFiles"},{"location":"Migrate%20notes/Migrate%20to%20v0.6.0/","text":"There's major breaking changes when updating to v0.6.0 , be careful. Update your pubspec.yaml : dependencies : shared_storage : ^0.6.0 Import statement \u00b6 Instead of: import 'package:shared_storage/environment.dart' as environment ; import 'package:shared_storage/media_store.dart' as environment ; import 'package:shared_storage/saf.dart' as environment ; Import as: import 'package:shared_storage/shared_storage' as shared_storage ; It's now has all APIs available under shared_storage key. getContent() and getContentAsString() \u00b6 Wrongly the previous versions required an unused parameter called destination : uri . getContentAsString ( uri ); uri . getContent ( uri ); It now has been removed: uri . getContentAsString (); uri . getContent ();","title":"Migrate to v0.6.0"},{"location":"Migrate%20notes/Migrate%20to%20v0.6.0/#import-statement","text":"Instead of: import 'package:shared_storage/environment.dart' as environment ; import 'package:shared_storage/media_store.dart' as environment ; import 'package:shared_storage/saf.dart' as environment ; Import as: import 'package:shared_storage/shared_storage' as shared_storage ; It's now has all APIs available under shared_storage key.","title":"Import statement"},{"location":"Migrate%20notes/Migrate%20to%20v0.6.0/#getcontent-and-getcontentasstring","text":"Wrongly the previous versions required an unused parameter called destination : uri . getContentAsString ( uri ); uri . getContent ( uri ); It now has been removed: uri . getContentAsString (); uri . getContent ();","title":"getContent() and getContentAsString()"},{"location":"Migrate%20notes/Migrate%20to%20v0.7.0/","text":"There's no major breaking changes when updating to v0.7.0 but there are deprecation notices if you are using Media Store and Environment API. Update your pubspec.yaml : dependencies : shared_storage : ^0.7.0 Deprecation notices \u00b6 All non SAF APIs are deprecated, if you are using them, let us know by opening an issue with your use-case so we can implement a new compatible API using a cross-platform approach.","title":"Migrate to v0.7.0"},{"location":"Migrate%20notes/Migrate%20to%20v0.7.0/#deprecation-notices","text":"All non SAF APIs are deprecated, if you are using them, let us know by opening an issue with your use-case so we can implement a new compatible API using a cross-platform approach.","title":"Deprecation notices"},{"location":"Usage/API%20Labeling/","text":"Warning \u00b6 This labeling will be removed soon, I it will be replaced with a full original API as described in #56 . Labeling \u00b6 When refering to the docs you'll usually see some labels before the method/class names. They are label which identifies where the API came from. This package is intended to be a mirror of native Android APIs. Which means all methods and classes are just a re-implementation of native APIs, but some places we can't do that due technical reasons. So we put a label to identify when it'll happen. You are fully encouraged to understand/learn the native Android APIs to use this package. All packages (not only this one) are derivated from native APIs depending on the platform (Windows, iOS, Android, Unix, Web, etc.), to have a understing about it can help not only here but on all your Flutter journey, and even in other frameworks. Label Description Internal New internal type (class). Usually they are only to keep a safe typing and are not usually intended to be instantiated for the package user. Original Original API which only exists inside this package and doesn't mirror any Android API (an abstraction). Mirror Pure mirror API (method/class) which was re-implemented in Dart from a native original API. Alias Convenient methods. They do not implement anything new but create a new abstraction from an existing API. External API from third-part Android libraries. Extension These are most alias methods implemented through Dart extensions.","title":"API Labeling"},{"location":"Usage/API%20Labeling/#warning","text":"This labeling will be removed soon, I it will be replaced with a full original API as described in #56 .","title":"Warning"},{"location":"Usage/API%20Labeling/#labeling","text":"When refering to the docs you'll usually see some labels before the method/class names. They are label which identifies where the API came from. This package is intended to be a mirror of native Android APIs. Which means all methods and classes are just a re-implementation of native APIs, but some places we can't do that due technical reasons. So we put a label to identify when it'll happen. You are fully encouraged to understand/learn the native Android APIs to use this package. All packages (not only this one) are derivated from native APIs depending on the platform (Windows, iOS, Android, Unix, Web, etc.), to have a understing about it can help not only here but on all your Flutter journey, and even in other frameworks. Label Description Internal New internal type (class). Usually they are only to keep a safe typing and are not usually intended to be instantiated for the package user. Original Original API which only exists inside this package and doesn't mirror any Android API (an abstraction). Mirror Pure mirror API (method/class) which was re-implemented in Dart from a native original API. Alias Convenient methods. They do not implement anything new but create a new abstraction from an existing API. External API from third-part Android libraries. Extension These are most alias methods implemented through Dart extensions.","title":"Labeling"},{"location":"Usage/Environment/","text":"WARNING This API is deprecated and will be removed soon. If you need it, please open an issue with your use-case to include in the next release as part of the new original cross-platform API. Import package \u00b6 import 'package:shared_storage/shared_storage.dart' as shared_storage ; Usage sample: shared_storage . getRootDirectory (...); shared_storage . getExternalStoragePublicDirectory (...); But if you import without alias import '...'; (Not recommeded because can conflict with other method/package names) you should use directly as functions: getRootDirectory (...); getExternalStoragePublicDirectory (...); Mirror methods \u00b6 Mirror methods are available to provide an way to call a native method without using any abstraction, available mirror methods: getRootDirectory \u00b6 Mirror of Environment.getRootDirectory Return root of the \"system\" partition holding the core Android OS. Always present and mounted read-only. Warning Some new Android versions return null because SAF is the new API to handle storage. final Directory ? rootDir = await getRootDirectory (); getExternalStoragePublicDirectory \u00b6 Mirror of Environment.getExternalStoragePublicDirectory Get a top-level shared/external storage directory for placing files of a particular type. This is where the user will typically place and manage their own files, so you should be careful about what you put here to ensure you don't erase their files or get in the way of their own organization. Warning Some new Android versions return null because SAF is the new API to handle storage. final Directory ? externalPublicDir = await getExternalStoragePublicDirectory ( EnvironmentDirectory . downloads ); getExternalStorageDirectory \u00b6 Mirror of Environment.getExternalStorageDirectory Return the primary shared/external storage directory. This directory may not currently be accessible if it has been mounted by the user on their computer, has been removed from the device, or some other problem has happened. Warning Some new Android versions return null because SAF is the new API to handle storage. final Directory ? externalDir = await getExternalStorageDirectory (); getDataDirectory \u00b6 Mirror of Environment.getDataDirectory Return the user data directory. Info What may not be obvious is that the \"user data directory\" returned by Environment.getDataDirectory is the system-wide data directory (i.e, typically so far /data ) and not an application specific directory. Applications of course are not allowed to write to the overall data directory, but only to their particular folder inside it or other select locations whose owner has granted access. Reference by Chris Stratton Warning Some new Android versions return null because SAF is the new API to handle storage. final Directory ? dataDir = await getDataDirectory (); getDownloadCacheDirectory \u00b6 Mirror of Environment.getDownloadCacheDirectory Return the download/cache content directory. Typically the /data/cache directory. Warning Some new Android versions return null because SAF is the new API to handle storage. final Directory ? downloadCacheDir = await getDownloadCacheDirectory (); getStorageDirectory \u00b6 Mirror of Environment.getStorageDirectory Return root directory where all external storage devices will be mounted. For example, getExternalStorageDirectory() will appear under this location. Warning Some new Android versions return null because SAF is the new API to handle storage. final Directory ? storageDir = await getStorageDirectory (); Android Official Documentation \u00b6 The Environment official documentation is available here. All the APIs listed in this plugin module are derivated from the official docs.","title":"Environment"},{"location":"Usage/Environment/#import-package","text":"import 'package:shared_storage/shared_storage.dart' as shared_storage ; Usage sample: shared_storage . getRootDirectory (...); shared_storage . getExternalStoragePublicDirectory (...); But if you import without alias import '...'; (Not recommeded because can conflict with other method/package names) you should use directly as functions: getRootDirectory (...); getExternalStoragePublicDirectory (...);","title":"Import package"},{"location":"Usage/Environment/#mirror-methods","text":"Mirror methods are available to provide an way to call a native method without using any abstraction, available mirror methods:","title":"Mirror methods"},{"location":"Usage/Environment/#getrootdirectory","text":"Mirror of Environment.getRootDirectory Return root of the \"system\" partition holding the core Android OS. Always present and mounted read-only. Warning Some new Android versions return null because SAF is the new API to handle storage. final Directory ? rootDir = await getRootDirectory ();","title":"getRootDirectory"},{"location":"Usage/Environment/#getexternalstoragepublicdirectory","text":"Mirror of Environment.getExternalStoragePublicDirectory Get a top-level shared/external storage directory for placing files of a particular type. This is where the user will typically place and manage their own files, so you should be careful about what you put here to ensure you don't erase their files or get in the way of their own organization. Warning Some new Android versions return null because SAF is the new API to handle storage. final Directory ? externalPublicDir = await getExternalStoragePublicDirectory ( EnvironmentDirectory . downloads );","title":"getExternalStoragePublicDirectory"},{"location":"Usage/Environment/#getexternalstoragedirectory","text":"Mirror of Environment.getExternalStorageDirectory Return the primary shared/external storage directory. This directory may not currently be accessible if it has been mounted by the user on their computer, has been removed from the device, or some other problem has happened. Warning Some new Android versions return null because SAF is the new API to handle storage. final Directory ? externalDir = await getExternalStorageDirectory ();","title":"getExternalStorageDirectory"},{"location":"Usage/Environment/#getdatadirectory","text":"Mirror of Environment.getDataDirectory Return the user data directory. Info What may not be obvious is that the \"user data directory\" returned by Environment.getDataDirectory is the system-wide data directory (i.e, typically so far /data ) and not an application specific directory. Applications of course are not allowed to write to the overall data directory, but only to their particular folder inside it or other select locations whose owner has granted access. Reference by Chris Stratton Warning Some new Android versions return null because SAF is the new API to handle storage. final Directory ? dataDir = await getDataDirectory ();","title":"getDataDirectory"},{"location":"Usage/Environment/#getdownloadcachedirectory","text":"Mirror of Environment.getDownloadCacheDirectory Return the download/cache content directory. Typically the /data/cache directory. Warning Some new Android versions return null because SAF is the new API to handle storage. final Directory ? downloadCacheDir = await getDownloadCacheDirectory ();","title":"getDownloadCacheDirectory"},{"location":"Usage/Environment/#getstoragedirectory","text":"Mirror of Environment.getStorageDirectory Return root directory where all external storage devices will be mounted. For example, getExternalStorageDirectory() will appear under this location. Warning Some new Android versions return null because SAF is the new API to handle storage. final Directory ? storageDir = await getStorageDirectory ();","title":"getStorageDirectory"},{"location":"Usage/Environment/#android-official-documentation","text":"The Environment official documentation is available here. All the APIs listed in this plugin module are derivated from the official docs.","title":"Android Official Documentation"},{"location":"Usage/Media%20Store/","text":"WARNING This API is deprecated and will be removed soon. If you need it, please open an issue with your use-case to include in the next release as part of the new original cross-platform API. Import package \u00b6 import 'package:shared_storage/shared_storage.dart' as shared_storage ; Usage sample: shared_storage . getMediaStoreContentDirectory (...); But if you import without alias import '...'; (Not recommeded because can conflict with other method/package names) you should use directly as functions: getMediaStoreContentDirectory (...); API reference \u00b6 Original API. These methods exists only in this package. Because methods are an abstraction from native API, for example: getMediaStoreContentDirectory is an abstraction because there's no such method in native Android, there you can access these directories synchronously and directly from the MediaStore nested classes which is not the goal of this package (re-create all Android APIs) but provide a powerful fully-configurable API to call these APIs. getMediaStoreContentDirectory \u00b6 Get the directory of a given Media Store Collection. The directory follows the Uri format To see all available collections see MediaStoreCollection class final Uri directory = getMediaStoreContentDirectory ( MediaStoreCollection . downloads ); Android Official Documentation \u00b6 The Media Store official documentation is available here. All the APIs listed in this plugin module are derivated from the official docs.","title":"Media Store"},{"location":"Usage/Media%20Store/#import-package","text":"import 'package:shared_storage/shared_storage.dart' as shared_storage ; Usage sample: shared_storage . getMediaStoreContentDirectory (...); But if you import without alias import '...'; (Not recommeded because can conflict with other method/package names) you should use directly as functions: getMediaStoreContentDirectory (...);","title":"Import package"},{"location":"Usage/Media%20Store/#api-reference","text":"Original API. These methods exists only in this package. Because methods are an abstraction from native API, for example: getMediaStoreContentDirectory is an abstraction because there's no such method in native Android, there you can access these directories synchronously and directly from the MediaStore nested classes which is not the goal of this package (re-create all Android APIs) but provide a powerful fully-configurable API to call these APIs.","title":"API reference"},{"location":"Usage/Media%20Store/#getmediastorecontentdirectory","text":"Get the directory of a given Media Store Collection. The directory follows the Uri format To see all available collections see MediaStoreCollection class final Uri directory = getMediaStoreContentDirectory ( MediaStoreCollection . downloads );","title":"getMediaStoreContentDirectory"},{"location":"Usage/Media%20Store/#android-official-documentation","text":"The Media Store official documentation is available here. All the APIs listed in this plugin module are derivated from the official docs.","title":"Android Official Documentation"},{"location":"Usage/Storage%20Access%20Framework/","text":"Import package \u00b6 import 'package:shared_storage/shared_storage.dart' as saf ; Usage sample: shared_storage . openDocumentTree (...); shared_storage . listFiles (...); But if you import without alias import '...'; (Not recommeded because can conflict with other method/package names) you should use directly as functions: openDocumentTree (...); listFiles (...); Example project \u00b6 The example project does use of most of these APIs, that is available at /example Concepts \u00b6 This is a brief explanation of the core concepts of this API. What's an Uri ? \u00b6 Uri is a the most confusing concept we can found. Since it's not a regular string, it's not a regular url, neither a regular file system path. By the official docs : A URI is a uniform resource identifier while a URL is a uniform resource locator. Hence every URL is a URI, abstractly speaking, but not every URI is a URL. This is because there is another subcategory of URIs, uniform resource names (URNs), which name resources but do not specify how to locate them. The mailto, news, and isbn URIs shown above are examples of URNs. Which translated means: this Uri can represent almost anything. Often this Uri s represent a folder or a file but not always. And different Uri s can point to the same file/folder Permission over an Uri \u00b6 To operate (read, delete, update, create) a file or folder within a directory, you need first to request permission of the user. These permissions are represented as UriPermission , reference . API Labeling \u00b6 See the label reference here . API reference \u00b6 Original API. These methods exists only in this package. Because methods are an abstraction from native API, for example: openDocumentTree is an abstraction because there's no such method in native Android, there you need to create a intent and start an activity which is not the goal of this package (re-create all Android APIs) but provide a powerful fully-configurable API to call these APIs. openDocumentTree \u00b6 This API allows you grant Uri s permission by calling like this: final Uri ? grantedUri = await openDocumentTree (); if ( grantedUri != null ) { print ( 'Now I have permission over this Uri: $ grantedUri ' ); } openDocument \u00b6 Same as openDocumentTree but for file URIs, you can request user to select a file and filter by: Single or multiple files. Mime type. You can also specify if you want a one-time operation ( persistablePermission = false) and if you don't need write access ( grantWritePermission = false). const kDownloadsFolder = 'content://com.android.externalstorage.documents/tree/primary%3ADownloads/document/primary%3ADownloads' ; final List < Uri >? selectedDocumentUris = await openDocument ( // if you have a previously saved URI, // you can use the specify the tree you user will see at startup of the file picker. initialUri: Uri . parse ( kDownloadsFolder ), // whether or not allow the user select multiple files. multiple: true , // whether or not the selected URIs should be persisted across app and device reboots. persistablePermission: true , // whether or not grant write permission required to edit file metadata (name) and it's contents. grantWritePermission: true , // whether or not filter by mime type. mimeType: 'image/*' // default '*/*' ); if ( selectedDocumentUris == null ) { return print ( 'User cancelled the operation.' ); } // If [selectedDocumentUris] are [persistablePermission]s then it will be returned by this function // along with any another URIs you've got permission over. final List < UriPermission > persistedUris = await persistedUriPermissions (); listFiles \u00b6 This method list files lazily over a granted uri: Note DocumentFileColumn.id is optional. It is required to fetch the file list from native API. So it is enabled regardless if you include this column or not. And this applies only to this API ( listFiles ). /// *Must* be a granted uri from `openDocumentTree`, or a URI representing a child under such a granted uri. final Uri myGrantedUri = ... final DocumentFile ? documentFileOfMyGrantedUri = await myGrantedUri . toDocumentFile (); if ( documentFileOfMyGrantedUri == null ) { return print ( 'This is not a valid Uri permission or you do not have the permission' ); } /// Columns/Fields you want access. Android handle storage as database. /// Allow you specify only the fields you need to use, avoiding querying unnecessary data const List < DocumentFileColumn > columns = < DocumentFileColumn > [ DocumentFileColumn . displayName , DocumentFileColumn . size , DocumentFileColumn . lastModified , DocumentFileColumn . id , // Optional column, will be available/queried regardless if is or not included here DocumentFileColumn . mimeType , ]; final List < DocumentFile > files = []; final Stream < DocumentFile > onNewFileLoaded = documentFileOfMyGrantedUri . listFiles ( columns ); onNewFileLoaded . listen (( file ) => files . add ( file ), onDone: () => print ( 'All files were loaded' )); openDocumentFile \u00b6 Open a file uri in a external app, by starting a new activity with ACTION_VIEW Intent. final Uri fileUri = ... /// This call will prompt the user: \"Open with\" dialog /// Or will open directly in the app if this there's only a single app that can handle this file type. await openDocumentFile ( fileUri ); getDocumentContent \u00b6 Read a document file from its uri by opening a input stream and returning its bytes. /// See also: [getDocumentContentAsString] final Uri uri = ... final Uint8List ? fileContent = await getDocumentContent ( uri ); /// Handle [fileContent]... /// If the file is intended to be human readable, you can convert the output to [String]: print ( String . fromCharCodes ( fileContent )); getRealPathFromUri \u00b6 Helper method to generate the file path of the given uri . This returns the real path to work with native old File API instead Uris, be aware this approach is no longer supported on Android 10+ (API 29+) and though new, this API is marked as deprecated and should be migrated to a scoped-storage approach. See Get real path from URI, Android KitKat new storage access framework for details. final Uri uri = ...; final String ? filePath = await getRealPathFromUri ( myUri ); final File file = File ( filePath ); Mirror methods \u00b6 Mirror methods are available to provide an way to call a native method without using any abstraction, available mirror methods: exists \u00b6 Mirror of DocumentFile.exists Returns true if a given uri exists. final Uri uri = ... if ( await exists ( uri ) ?? false ) { print ( 'There is no granted Uris' ); } else { print ( 'My granted Uris: $ grantedUris ' ); } persistedUriPermissions \u00b6 Mirror of ContentResolver.getPersistedUriPermissions Basically this allow get the granted Uri s permissions after the app restarts without the need of requesting the folders again. final List < UriPermission >? grantedUris = await persistedUriPermissions (); if ( grantedUris != null ) { print ( 'There is no granted Uris' ); } else { print ( 'My granted Uris: $ grantedUris ' ); } From the official docs: Return list of all URI permission grants that have been persisted by the calling app. That is, the returned permissions have been granted to the calling app. Only persistable grants taken with takePersistableUriPermission(android.net.Uri, int) are returned. Note: Some of the returned URIs may not be usable until after the user is unlocked. releasePersistableUriPermission \u00b6 Mirror of ContentResolver.releasePersistableUriPermission Opposite of openDocumentTree . This method revoke all permissions you have under a specific Uri . This should be used to allow the user revoke the permission of Uri s inside your app without needing revoking at OS level. final List < UriPermission > grantedUris = ... /// Revoke all granted Uris for ( final UriPermission uri of grantedUris ) { await releasePersistableUriPermission ( uri ); } /// You can also revoke a single Uri await releasePersistableUriPermission ( grantedUris [ 0 ]); createFileAsBytes \u00b6 Mirror of DocumentFile.createFile Create a file using raw bytes Uint8List . Given the parent uri, creates a new child document file that represents a single file given the displayName , mimeType and its content in bytes (file name, file type and file content in raw bytes, respectively). final Uri parentUri = ... final String fileContent = 'My File Content' ; final DocumentFile ? createdFile = createFileAsBytes ( parentUri , mimeType: 'text/plain' , displayName: 'Sample File Name' , bytes: Uint8List . fromList ( fileContent . codeUnits ), ); writeToFileAsBytes \u00b6 Write to a file using raw bytes Uint8List . Given the document uri, opens the file in the specified mode and writes the bytes to it. mode represents the mode in which the file will be opened for writing. Use FileMode.write for truncating (overwrite) and FileMode.append for appending to the file. final Uri documentUri = ... final String fileContent = 'My File Content' ; /// Write to a file using a [Uint8List] as file contents [bytes] final bool ? success = writeToFileAsBytes ( documentUri , bytes: Uint8List . fromList ( fileContent . codeUnits ), mode: FileMode . write , ); /// Append to a file using a [Uint8List] as file contents [bytes] final bool ? success = writeToFileAsBytes ( documentUri , bytes: Uint8List . fromList ( fileContent . codeUnits ), mode: FileMode . write , ); canRead \u00b6 Mirror of DocumentFile.canRead Returns true if the caller can read the given uri , that is, if has the properly permissions. final Uri uri = ... if ( await canRead ( uri ) ?? false ) { print ( 'I have permissions to read $ uri ' ); final Uint8List ? fileContent = await getDocumentContent ( uri ); /// ... } else { final UriPermission ? permission = openDocumentTree ( uri ); /// ... } canWrite \u00b6 Mirror of DocumentFile.canWrite Returns true if the caller can write the given uri , that is, if has the properly permissions. final Uri uri = ... if ( await canWrite ( uri ) ?? false ) { print ( 'I have permissions to write $ uri ' ); final Uint8List ? fileContent = await renameTo ( uri , 'New File Name' ); /// ... } else { final UriPermission ? permission = openDocumentTree ( uri , grantWritePermission: true , ); /// ... } getDocumentThumbnail \u00b6 Mirror of DocumentsContract.getDocumentThumbnail Returns the image thumbnail of a given uri , if any (e.g documents that can show a preview, like images of gifs , null otherwise). final Uint8List ? imageBytes ; final DocumentFile file = ... final Uri ? rootUri = file . metadata ? . rootUri ; final String ? documentId = file . data ? [ DocumentFileColumn . id ] as String ? ; if ( rootUri == null || documentId == null ) return ; final DocumentBitmap ? bitmap = await getDocumentThumbnail ( rootUri: rootUri , documentId: documentId , width: _size . width , height: _size . height , ); if ( bitmap == null || ! mounted ) return ; setState (() => imageBytes = bitmap . bytes ); /// Later on... @override Widget build ( BuildContext context ) { if ( imageBytes == null ) return Loading ( 'My cool loading spinner' ); return Image . memory ( imageBytes ); } DocumentFileColumn \u00b6 Mirror of DocumentsContract.Document.<Column> Use this class to refer to the SAF queryable columns in methods that requires granular/partial data fetch. For instance, in listFiles a large set can be returned, and to improve performance you can provide only the columns you want access/read. /// Columns/Fields you want access. Android handle storage as database. /// Allow you specify only the fields you need to use, avoiding querying unnecessary data const List < DocumentFileColumn > columns = < DocumentFileColumn > [ DocumentFileColumn . displayName , DocumentFileColumn . size , DocumentFileColumn . lastModified , DocumentFileColumn . id , DocumentFileColumn . mimeType , ]; final Stream < DocumentFile > onNewFileLoaded = documentFileOfMyGrantedUri . listFiles ( columns ); delete \u00b6 Mirror of DocumentFile.delete Self explanatory, but just in case: delete the target uri (document file). final Uri uri = ... await delete ( uri ); createDirectory \u00b6 Mirror of DocumentFile.createDirectory Self explanatory, but just in case: creates a new child document file that represents a directory given the displayName (folder name). final Uri parentUri = ... await createDirectory ( parentUri , 'My Folder Name' ); documentLength \u00b6 Mirror of DocumentFile.length Returns the length of this file in bytes. Returns 0 if the file does not exist, or if the length is unknown. final Uri uri = ... final int ? fileSize = await documentLength ( uri ); lastModified \u00b6 Mirror of DocumentFile.lastModified Returns the time DateTime when this file was last modified. Returns null if the file does not exist, or if the modified time is unknown. final Uri uri = ... final int ? fileSize = await documentLength ( uri ); findFile \u00b6 Mirror of DocumentFile.findFile Search through listFiles() for the first document matching the given display name, this method has a really poor performance for large data sets. final Uri directoryUri = ... final DocumentFile ? match = await findFile ( directoryUri , 'Target File Name' ); fromTreeUri \u00b6 Mirror of DocumentFile.fromTreeUri Create a DocumentFile representing the document tree rooted at the given Uri . final Uri uri = ... final DocumentFile ? treeUri = fromTreeUri ( uri ); renameTo \u00b6 Mirror of DocumentFile.renameTo Self explanatory, but just in case: rename the given document file given its uri and a new display name. final Uri uri = ... await renameTo ( uri , 'New Document Name' ); parentFile \u00b6 Mirror of DocumentFile.parentFile Returns the parent document file of a given document file (uri). null if you do not have permission to see the parent folder. final Uri uri = ... final DocumentFile ? parentUri = await parentFile ( uri ); copy \u00b6 Mirror of DocumentsContract.copyDocument Copy the given uri to a new destinationUri . final Uri uri = ... final Uri destination = ... final DocumentFile ? copiedFile = await copy ( uri , destination ); Alias methods \u00b6 These APIs are only shortcuts/alias, that is, they do not call native code directly, these are just convenient methods. isPersistedUri \u00b6 Alias for persistedUriPermissions Check if a given Uri is persisted/granted, that is, you have permission over it. /// Can be any Uri final Uri maybeGrantedUri = ... final bool ensureThisIsGrantedUri = await isPersistedUri ( maybeGrantedUri ); if ( ensureThisIsGrantedUri ) { print ( 'I have permission over the Uri: $ maybeGrantedUri ' ); } getDocumentContentAsString \u00b6 Alias for getDocumentContent Read a document file from its uri by opening a input stream, reading its bytes and converting to String . final Uri uri = ... final String ? fileContent = await getDocumentContentAsString ( uri ); print ( fileContent ); createFileAsString \u00b6 Alias for createFileAsBytes Convenient method to create a file using content as String instead Uint8List . final Uri parentUri = ... final String fileContent = 'My File Content' ; final DocumentFile ? createdFile = createFileAsString ( parentUri , mimeType: 'text/plain' , displayName: 'Sample File Name' , content: fileContent , ); writeToFileAsString \u00b6 Alias for writeToFileAsBytes Convenient method to write to a file using content as String instead Uint8List . final Uri documentUri = ... final String fileContent = 'My File Content' ; /// Write to a file using a [Uint8List] as file contents [bytes] final bool ? success = writeToFileAsString ( documentUri , content: fileContent , mode: FileMode . write , ); /// Append to a file using a [Uint8List] as file contents [bytes] final bool ? success = writeToFileAsBytes ( documentUri , content: fileContent , mode: FileMode . write , ); createFile \u00b6 Alias for createFileAsBytes and createFileAsString Convenient method to create a file using content as String or bytes as Uint8List . You should provide either content or bytes , if both bytes will be used. final Uri parentUri = ... final String fileContent = 'My File Content' ; /// Create a file using a [String] as file contents [content] final DocumentFile ? createdFile = createFile ( parentUri , mimeType: 'text/plain' , displayName: 'Sample File Name' , content: fileContent , ); /// Create a file using a [Uint8List] as file contents [bytes] final DocumentFile ? createdFile = createFile ( parentUri , mimeType: 'text/plain' , displayName: 'Sample File Name' , content: Uint8List . fromList ( fileContent . codeUnits ), ); writeToFile \u00b6 Alias for writeToFileAsBytes and writeToFileAsString Convenient method to write to a file using content as String or bytes as Uint8List . You should provide either content or bytes , if both bytes will be used. mode represents the mode in which the file will be opened for writing. Use FileMode.write for truncating and FileMode.append for appending to the file. final Uri documentUri = ... final String fileContent = 'My File Content' ; /// Write to a file using a [String] as file contents [content] final bool ? success = writeToFile ( documentUri , content: fileContent , mode: FileMode . write , ); /// Append to a file using a [String] as file contents [content] final bool ? success = writeToFile ( documentUri , content: fileContent , mode: FileMode . append , ); /// Write to a file using a [Uint8List] as file contents [bytes] final bool ? success = writeToFile ( documentUri , content: Uint8List . fromList ( fileContent . codeUnits ), mode: FileMode . write , ); /// Append to a file using a [Uint8List] as file contents [bytes] final bool ? success = writeToFile ( documentUri , content: Uint8List . fromList ( fileContent . codeUnits ), mode: FileMode . append , ); External APIs (deprecated) \u00b6 These APIs are from external Android libraries. Will be moved to another package soon. child \u00b6 Mirror of com.anggrayudi.storage.file.DocumentFile.child Get the direct child of the given uri. Can be used to verify if a file already exists and check for conflicts. final Uri parentUri = ... final DocumentFile ? childDocument = child ( parentUri , 'Sample File Name' ); if ( childDocument != null ) { /// This child exists... } else { /// Doesn't exists... } Internal Types (Classes) \u00b6 Internal type (class). Usually they are only to keep a safe typing and are not usually intended to be instantiated for the package user. DocumentFile \u00b6 This class represents but is not the mirror of the original DocumentFile . This class is not intended to be instantiated, and it is only used for typing and convenient purposes. QueryMetadata \u00b6 This class wraps useful metadata of the source queries returned by the DocumentFile . This class is not intended to be instantiated, and it is only used for typing and convenience purposes. DocumentBitmap \u00b6 This class represent the bitmap/image of a document. Usually the thumbnail of the document. Should be used to show a list/grid preview of a file list. See also getDocumentThumbnail . This class is not intended to be instantiated, and it is only used for typing and convenient purposes. Extensions \u00b6 These are most alias methods implemented through Dart extensions. Uri.toDocumentFile on Uri \u00b6 Alias for DocumentFile.fromTreeUri(this) This method convert this uri to the respective DocumentFile (if exists, otherwise null ). final Uri uri = ... final DocumentFile ? documentFile = uri . toDocumentFile (); Uri.openDocumentFile on Uri \u00b6 Alias for openDocumentFile(this) This method open the current uri in a third-part application through ACTION_VIEW intent. final Uri uri = ... await uri . openDocumentFile (); Android Official Documentation \u00b6 The Storage Access Framework official documentation is available here. All the APIs listed in this plugin module are derivated from the official docs.","title":"Storage Access Framework"},{"location":"Usage/Storage%20Access%20Framework/#import-package","text":"import 'package:shared_storage/shared_storage.dart' as saf ; Usage sample: shared_storage . openDocumentTree (...); shared_storage . listFiles (...); But if you import without alias import '...'; (Not recommeded because can conflict with other method/package names) you should use directly as functions: openDocumentTree (...); listFiles (...);","title":"Import package"},{"location":"Usage/Storage%20Access%20Framework/#example-project","text":"The example project does use of most of these APIs, that is available at /example","title":"Example project"},{"location":"Usage/Storage%20Access%20Framework/#concepts","text":"This is a brief explanation of the core concepts of this API.","title":"Concepts"},{"location":"Usage/Storage%20Access%20Framework/#whats-an-uri","text":"Uri is a the most confusing concept we can found. Since it's not a regular string, it's not a regular url, neither a regular file system path. By the official docs : A URI is a uniform resource identifier while a URL is a uniform resource locator. Hence every URL is a URI, abstractly speaking, but not every URI is a URL. This is because there is another subcategory of URIs, uniform resource names (URNs), which name resources but do not specify how to locate them. The mailto, news, and isbn URIs shown above are examples of URNs. Which translated means: this Uri can represent almost anything. Often this Uri s represent a folder or a file but not always. And different Uri s can point to the same file/folder","title":"What's an Uri?"},{"location":"Usage/Storage%20Access%20Framework/#permission-over-an-uri","text":"To operate (read, delete, update, create) a file or folder within a directory, you need first to request permission of the user. These permissions are represented as UriPermission , reference .","title":"Permission over an Uri"},{"location":"Usage/Storage%20Access%20Framework/#api-labeling","text":"See the label reference here .","title":"API Labeling"},{"location":"Usage/Storage%20Access%20Framework/#api-reference","text":"Original API. These methods exists only in this package. Because methods are an abstraction from native API, for example: openDocumentTree is an abstraction because there's no such method in native Android, there you need to create a intent and start an activity which is not the goal of this package (re-create all Android APIs) but provide a powerful fully-configurable API to call these APIs.","title":"API reference"},{"location":"Usage/Storage%20Access%20Framework/#opendocumenttree","text":"This API allows you grant Uri s permission by calling like this: final Uri ? grantedUri = await openDocumentTree (); if ( grantedUri != null ) { print ( 'Now I have permission over this Uri: $ grantedUri ' ); }","title":"openDocumentTree"},{"location":"Usage/Storage%20Access%20Framework/#opendocument","text":"Same as openDocumentTree but for file URIs, you can request user to select a file and filter by: Single or multiple files. Mime type. You can also specify if you want a one-time operation ( persistablePermission = false) and if you don't need write access ( grantWritePermission = false). const kDownloadsFolder = 'content://com.android.externalstorage.documents/tree/primary%3ADownloads/document/primary%3ADownloads' ; final List < Uri >? selectedDocumentUris = await openDocument ( // if you have a previously saved URI, // you can use the specify the tree you user will see at startup of the file picker. initialUri: Uri . parse ( kDownloadsFolder ), // whether or not allow the user select multiple files. multiple: true , // whether or not the selected URIs should be persisted across app and device reboots. persistablePermission: true , // whether or not grant write permission required to edit file metadata (name) and it's contents. grantWritePermission: true , // whether or not filter by mime type. mimeType: 'image/*' // default '*/*' ); if ( selectedDocumentUris == null ) { return print ( 'User cancelled the operation.' ); } // If [selectedDocumentUris] are [persistablePermission]s then it will be returned by this function // along with any another URIs you've got permission over. final List < UriPermission > persistedUris = await persistedUriPermissions ();","title":"openDocument"},{"location":"Usage/Storage%20Access%20Framework/#listfiles","text":"This method list files lazily over a granted uri: Note DocumentFileColumn.id is optional. It is required to fetch the file list from native API. So it is enabled regardless if you include this column or not. And this applies only to this API ( listFiles ). /// *Must* be a granted uri from `openDocumentTree`, or a URI representing a child under such a granted uri. final Uri myGrantedUri = ... final DocumentFile ? documentFileOfMyGrantedUri = await myGrantedUri . toDocumentFile (); if ( documentFileOfMyGrantedUri == null ) { return print ( 'This is not a valid Uri permission or you do not have the permission' ); } /// Columns/Fields you want access. Android handle storage as database. /// Allow you specify only the fields you need to use, avoiding querying unnecessary data const List < DocumentFileColumn > columns = < DocumentFileColumn > [ DocumentFileColumn . displayName , DocumentFileColumn . size , DocumentFileColumn . lastModified , DocumentFileColumn . id , // Optional column, will be available/queried regardless if is or not included here DocumentFileColumn . mimeType , ]; final List < DocumentFile > files = []; final Stream < DocumentFile > onNewFileLoaded = documentFileOfMyGrantedUri . listFiles ( columns ); onNewFileLoaded . listen (( file ) => files . add ( file ), onDone: () => print ( 'All files were loaded' ));","title":"listFiles"},{"location":"Usage/Storage%20Access%20Framework/#opendocumentfile","text":"Open a file uri in a external app, by starting a new activity with ACTION_VIEW Intent. final Uri fileUri = ... /// This call will prompt the user: \"Open with\" dialog /// Or will open directly in the app if this there's only a single app that can handle this file type. await openDocumentFile ( fileUri );","title":"openDocumentFile"},{"location":"Usage/Storage%20Access%20Framework/#getdocumentcontent","text":"Read a document file from its uri by opening a input stream and returning its bytes. /// See also: [getDocumentContentAsString] final Uri uri = ... final Uint8List ? fileContent = await getDocumentContent ( uri ); /// Handle [fileContent]... /// If the file is intended to be human readable, you can convert the output to [String]: print ( String . fromCharCodes ( fileContent ));","title":"getDocumentContent"},{"location":"Usage/Storage%20Access%20Framework/#getrealpathfromuri","text":"Helper method to generate the file path of the given uri . This returns the real path to work with native old File API instead Uris, be aware this approach is no longer supported on Android 10+ (API 29+) and though new, this API is marked as deprecated and should be migrated to a scoped-storage approach. See Get real path from URI, Android KitKat new storage access framework for details. final Uri uri = ...; final String ? filePath = await getRealPathFromUri ( myUri ); final File file = File ( filePath );","title":"getRealPathFromUri"},{"location":"Usage/Storage%20Access%20Framework/#mirror-methods","text":"Mirror methods are available to provide an way to call a native method without using any abstraction, available mirror methods:","title":"Mirror methods"},{"location":"Usage/Storage%20Access%20Framework/#exists","text":"Mirror of DocumentFile.exists Returns true if a given uri exists. final Uri uri = ... if ( await exists ( uri ) ?? false ) { print ( 'There is no granted Uris' ); } else { print ( 'My granted Uris: $ grantedUris ' ); }","title":"exists"},{"location":"Usage/Storage%20Access%20Framework/#persisteduripermissions","text":"Mirror of ContentResolver.getPersistedUriPermissions Basically this allow get the granted Uri s permissions after the app restarts without the need of requesting the folders again. final List < UriPermission >? grantedUris = await persistedUriPermissions (); if ( grantedUris != null ) { print ( 'There is no granted Uris' ); } else { print ( 'My granted Uris: $ grantedUris ' ); } From the official docs: Return list of all URI permission grants that have been persisted by the calling app. That is, the returned permissions have been granted to the calling app. Only persistable grants taken with takePersistableUriPermission(android.net.Uri, int) are returned. Note: Some of the returned URIs may not be usable until after the user is unlocked.","title":"persistedUriPermissions"},{"location":"Usage/Storage%20Access%20Framework/#releasepersistableuripermission","text":"Mirror of ContentResolver.releasePersistableUriPermission Opposite of openDocumentTree . This method revoke all permissions you have under a specific Uri . This should be used to allow the user revoke the permission of Uri s inside your app without needing revoking at OS level. final List < UriPermission > grantedUris = ... /// Revoke all granted Uris for ( final UriPermission uri of grantedUris ) { await releasePersistableUriPermission ( uri ); } /// You can also revoke a single Uri await releasePersistableUriPermission ( grantedUris [ 0 ]);","title":"releasePersistableUriPermission"},{"location":"Usage/Storage%20Access%20Framework/#createfileasbytes","text":"Mirror of DocumentFile.createFile Create a file using raw bytes Uint8List . Given the parent uri, creates a new child document file that represents a single file given the displayName , mimeType and its content in bytes (file name, file type and file content in raw bytes, respectively). final Uri parentUri = ... final String fileContent = 'My File Content' ; final DocumentFile ? createdFile = createFileAsBytes ( parentUri , mimeType: 'text/plain' , displayName: 'Sample File Name' , bytes: Uint8List . fromList ( fileContent . codeUnits ), );","title":"createFileAsBytes"},{"location":"Usage/Storage%20Access%20Framework/#writetofileasbytes","text":"Write to a file using raw bytes Uint8List . Given the document uri, opens the file in the specified mode and writes the bytes to it. mode represents the mode in which the file will be opened for writing. Use FileMode.write for truncating (overwrite) and FileMode.append for appending to the file. final Uri documentUri = ... final String fileContent = 'My File Content' ; /// Write to a file using a [Uint8List] as file contents [bytes] final bool ? success = writeToFileAsBytes ( documentUri , bytes: Uint8List . fromList ( fileContent . codeUnits ), mode: FileMode . write , ); /// Append to a file using a [Uint8List] as file contents [bytes] final bool ? success = writeToFileAsBytes ( documentUri , bytes: Uint8List . fromList ( fileContent . codeUnits ), mode: FileMode . write , );","title":"writeToFileAsBytes"},{"location":"Usage/Storage%20Access%20Framework/#canread","text":"Mirror of DocumentFile.canRead Returns true if the caller can read the given uri , that is, if has the properly permissions. final Uri uri = ... if ( await canRead ( uri ) ?? false ) { print ( 'I have permissions to read $ uri ' ); final Uint8List ? fileContent = await getDocumentContent ( uri ); /// ... } else { final UriPermission ? permission = openDocumentTree ( uri ); /// ... }","title":"canRead"},{"location":"Usage/Storage%20Access%20Framework/#canwrite","text":"Mirror of DocumentFile.canWrite Returns true if the caller can write the given uri , that is, if has the properly permissions. final Uri uri = ... if ( await canWrite ( uri ) ?? false ) { print ( 'I have permissions to write $ uri ' ); final Uint8List ? fileContent = await renameTo ( uri , 'New File Name' ); /// ... } else { final UriPermission ? permission = openDocumentTree ( uri , grantWritePermission: true , ); /// ... }","title":"canWrite"},{"location":"Usage/Storage%20Access%20Framework/#getdocumentthumbnail","text":"Mirror of DocumentsContract.getDocumentThumbnail Returns the image thumbnail of a given uri , if any (e.g documents that can show a preview, like images of gifs , null otherwise). final Uint8List ? imageBytes ; final DocumentFile file = ... final Uri ? rootUri = file . metadata ? . rootUri ; final String ? documentId = file . data ? [ DocumentFileColumn . id ] as String ? ; if ( rootUri == null || documentId == null ) return ; final DocumentBitmap ? bitmap = await getDocumentThumbnail ( rootUri: rootUri , documentId: documentId , width: _size . width , height: _size . height , ); if ( bitmap == null || ! mounted ) return ; setState (() => imageBytes = bitmap . bytes ); /// Later on... @override Widget build ( BuildContext context ) { if ( imageBytes == null ) return Loading ( 'My cool loading spinner' ); return Image . memory ( imageBytes ); }","title":"getDocumentThumbnail"},{"location":"Usage/Storage%20Access%20Framework/#documentfilecolumn","text":"Mirror of DocumentsContract.Document.<Column> Use this class to refer to the SAF queryable columns in methods that requires granular/partial data fetch. For instance, in listFiles a large set can be returned, and to improve performance you can provide only the columns you want access/read. /// Columns/Fields you want access. Android handle storage as database. /// Allow you specify only the fields you need to use, avoiding querying unnecessary data const List < DocumentFileColumn > columns = < DocumentFileColumn > [ DocumentFileColumn . displayName , DocumentFileColumn . size , DocumentFileColumn . lastModified , DocumentFileColumn . id , DocumentFileColumn . mimeType , ]; final Stream < DocumentFile > onNewFileLoaded = documentFileOfMyGrantedUri . listFiles ( columns );","title":"DocumentFileColumn"},{"location":"Usage/Storage%20Access%20Framework/#delete","text":"Mirror of DocumentFile.delete Self explanatory, but just in case: delete the target uri (document file). final Uri uri = ... await delete ( uri );","title":"delete"},{"location":"Usage/Storage%20Access%20Framework/#createdirectory","text":"Mirror of DocumentFile.createDirectory Self explanatory, but just in case: creates a new child document file that represents a directory given the displayName (folder name). final Uri parentUri = ... await createDirectory ( parentUri , 'My Folder Name' );","title":"createDirectory"},{"location":"Usage/Storage%20Access%20Framework/#documentlength","text":"Mirror of DocumentFile.length Returns the length of this file in bytes. Returns 0 if the file does not exist, or if the length is unknown. final Uri uri = ... final int ? fileSize = await documentLength ( uri );","title":"documentLength"},{"location":"Usage/Storage%20Access%20Framework/#lastmodified","text":"Mirror of DocumentFile.lastModified Returns the time DateTime when this file was last modified. Returns null if the file does not exist, or if the modified time is unknown. final Uri uri = ... final int ? fileSize = await documentLength ( uri );","title":"lastModified"},{"location":"Usage/Storage%20Access%20Framework/#findfile","text":"Mirror of DocumentFile.findFile Search through listFiles() for the first document matching the given display name, this method has a really poor performance for large data sets. final Uri directoryUri = ... final DocumentFile ? match = await findFile ( directoryUri , 'Target File Name' );","title":"findFile"},{"location":"Usage/Storage%20Access%20Framework/#fromtreeuri","text":"Mirror of DocumentFile.fromTreeUri Create a DocumentFile representing the document tree rooted at the given Uri . final Uri uri = ... final DocumentFile ? treeUri = fromTreeUri ( uri );","title":"fromTreeUri"},{"location":"Usage/Storage%20Access%20Framework/#renameto","text":"Mirror of DocumentFile.renameTo Self explanatory, but just in case: rename the given document file given its uri and a new display name. final Uri uri = ... await renameTo ( uri , 'New Document Name' );","title":"renameTo"},{"location":"Usage/Storage%20Access%20Framework/#parentfile","text":"Mirror of DocumentFile.parentFile Returns the parent document file of a given document file (uri). null if you do not have permission to see the parent folder. final Uri uri = ... final DocumentFile ? parentUri = await parentFile ( uri );","title":"parentFile"},{"location":"Usage/Storage%20Access%20Framework/#copy","text":"Mirror of DocumentsContract.copyDocument Copy the given uri to a new destinationUri . final Uri uri = ... final Uri destination = ... final DocumentFile ? copiedFile = await copy ( uri , destination );","title":"copy"},{"location":"Usage/Storage%20Access%20Framework/#alias-methods","text":"These APIs are only shortcuts/alias, that is, they do not call native code directly, these are just convenient methods.","title":"Alias methods"},{"location":"Usage/Storage%20Access%20Framework/#ispersisteduri","text":"Alias for persistedUriPermissions Check if a given Uri is persisted/granted, that is, you have permission over it. /// Can be any Uri final Uri maybeGrantedUri = ... final bool ensureThisIsGrantedUri = await isPersistedUri ( maybeGrantedUri ); if ( ensureThisIsGrantedUri ) { print ( 'I have permission over the Uri: $ maybeGrantedUri ' ); }","title":"isPersistedUri"},{"location":"Usage/Storage%20Access%20Framework/#getdocumentcontentasstring","text":"Alias for getDocumentContent Read a document file from its uri by opening a input stream, reading its bytes and converting to String . final Uri uri = ... final String ? fileContent = await getDocumentContentAsString ( uri ); print ( fileContent );","title":"getDocumentContentAsString"},{"location":"Usage/Storage%20Access%20Framework/#createfileasstring","text":"Alias for createFileAsBytes Convenient method to create a file using content as String instead Uint8List . final Uri parentUri = ... final String fileContent = 'My File Content' ; final DocumentFile ? createdFile = createFileAsString ( parentUri , mimeType: 'text/plain' , displayName: 'Sample File Name' , content: fileContent , );","title":"createFileAsString"},{"location":"Usage/Storage%20Access%20Framework/#writetofileasstring","text":"Alias for writeToFileAsBytes Convenient method to write to a file using content as String instead Uint8List . final Uri documentUri = ... final String fileContent = 'My File Content' ; /// Write to a file using a [Uint8List] as file contents [bytes] final bool ? success = writeToFileAsString ( documentUri , content: fileContent , mode: FileMode . write , ); /// Append to a file using a [Uint8List] as file contents [bytes] final bool ? success = writeToFileAsBytes ( documentUri , content: fileContent , mode: FileMode . write , );","title":"writeToFileAsString"},{"location":"Usage/Storage%20Access%20Framework/#createfile","text":"Alias for createFileAsBytes and createFileAsString Convenient method to create a file using content as String or bytes as Uint8List . You should provide either content or bytes , if both bytes will be used. final Uri parentUri = ... final String fileContent = 'My File Content' ; /// Create a file using a [String] as file contents [content] final DocumentFile ? createdFile = createFile ( parentUri , mimeType: 'text/plain' , displayName: 'Sample File Name' , content: fileContent , ); /// Create a file using a [Uint8List] as file contents [bytes] final DocumentFile ? createdFile = createFile ( parentUri , mimeType: 'text/plain' , displayName: 'Sample File Name' , content: Uint8List . fromList ( fileContent . codeUnits ), );","title":"createFile"},{"location":"Usage/Storage%20Access%20Framework/#writetofile","text":"Alias for writeToFileAsBytes and writeToFileAsString Convenient method to write to a file using content as String or bytes as Uint8List . You should provide either content or bytes , if both bytes will be used. mode represents the mode in which the file will be opened for writing. Use FileMode.write for truncating and FileMode.append for appending to the file. final Uri documentUri = ... final String fileContent = 'My File Content' ; /// Write to a file using a [String] as file contents [content] final bool ? success = writeToFile ( documentUri , content: fileContent , mode: FileMode . write , ); /// Append to a file using a [String] as file contents [content] final bool ? success = writeToFile ( documentUri , content: fileContent , mode: FileMode . append , ); /// Write to a file using a [Uint8List] as file contents [bytes] final bool ? success = writeToFile ( documentUri , content: Uint8List . fromList ( fileContent . codeUnits ), mode: FileMode . write , ); /// Append to a file using a [Uint8List] as file contents [bytes] final bool ? success = writeToFile ( documentUri , content: Uint8List . fromList ( fileContent . codeUnits ), mode: FileMode . append , );","title":"writeToFile"},{"location":"Usage/Storage%20Access%20Framework/#external-apis-deprecated","text":"These APIs are from external Android libraries. Will be moved to another package soon.","title":"External APIs (deprecated)"},{"location":"Usage/Storage%20Access%20Framework/#child","text":"Mirror of com.anggrayudi.storage.file.DocumentFile.child Get the direct child of the given uri. Can be used to verify if a file already exists and check for conflicts. final Uri parentUri = ... final DocumentFile ? childDocument = child ( parentUri , 'Sample File Name' ); if ( childDocument != null ) { /// This child exists... } else { /// Doesn't exists... }","title":"child"},{"location":"Usage/Storage%20Access%20Framework/#internal-types-classes","text":"Internal type (class). Usually they are only to keep a safe typing and are not usually intended to be instantiated for the package user.","title":"Internal Types (Classes)"},{"location":"Usage/Storage%20Access%20Framework/#documentfile","text":"This class represents but is not the mirror of the original DocumentFile . This class is not intended to be instantiated, and it is only used for typing and convenient purposes.","title":"DocumentFile"},{"location":"Usage/Storage%20Access%20Framework/#querymetadata","text":"This class wraps useful metadata of the source queries returned by the DocumentFile . This class is not intended to be instantiated, and it is only used for typing and convenience purposes.","title":"QueryMetadata"},{"location":"Usage/Storage%20Access%20Framework/#documentbitmap","text":"This class represent the bitmap/image of a document. Usually the thumbnail of the document. Should be used to show a list/grid preview of a file list. See also getDocumentThumbnail . This class is not intended to be instantiated, and it is only used for typing and convenient purposes.","title":"DocumentBitmap"},{"location":"Usage/Storage%20Access%20Framework/#extensions","text":"These are most alias methods implemented through Dart extensions.","title":"Extensions"},{"location":"Usage/Storage%20Access%20Framework/#uritodocumentfile-on-uri","text":"Alias for DocumentFile.fromTreeUri(this) This method convert this uri to the respective DocumentFile (if exists, otherwise null ). final Uri uri = ... final DocumentFile ? documentFile = uri . toDocumentFile ();","title":"Uri.toDocumentFile on Uri"},{"location":"Usage/Storage%20Access%20Framework/#uriopendocumentfile-on-uri","text":"Alias for openDocumentFile(this) This method open the current uri in a third-part application through ACTION_VIEW intent. final Uri uri = ... await uri . openDocumentFile ();","title":"Uri.openDocumentFile on Uri"},{"location":"Usage/Storage%20Access%20Framework/#android-official-documentation","text":"The Storage Access Framework official documentation is available here. All the APIs listed in this plugin module are derivated from the official docs.","title":"Android Official Documentation"}]}